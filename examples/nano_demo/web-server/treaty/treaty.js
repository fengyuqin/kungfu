// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save protocol-buffers-encodings`
var encodings = require('protocol-buffers-encodings')
var varint = encodings.varint
var skip = encodings.skip

exports.CodeType = {
  CodeSuccess: 0,
  CodeFailed: 1,
  CodeChooseBackendLogin: 2,
  CodeLoginReconnect: 3,
  CodeCannotFindBackend: 4,
  CodeUndefinedDealMsg: 5,
  CodeNotLogin: 6,
  CodeNotRightConnector: 7,
  CodeNotLoginBackend: 8
}

exports.MsgId = {
  "Msg_None": 0,
  "Msg_Login_Request": 1,
  "Msg_Login_Response": 2,
  "Msg_Multi_Login_Out": 3,
  "Msg_Logout_Request": 4,
  "Msg_Logout_Response": 5,
  "Msg_Channel_Request": 6,
  "Msg_Channel_Response": 7
}

exports.RpcMsgId = {
  RpcMsgNone: 0,
  RpcMsgMultiLoginOut: 1,
  RpcMsgBackendLogin: 2,
  RpcMsgBackendLogout: 3,
  RpcMsgChatTest: 4
}

var Server = exports.Server = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var BalanceResult = exports.BalanceResult = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var Session = exports.Session = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var GameChannel = exports.GameChannel = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var MultiLoginOut = exports.MultiLoginOut = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LoginRequest = exports.LoginRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LoginResponse = exports.LoginResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var RpcMsg = exports.RpcMsg = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LogoutRequest = exports.LogoutRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var LogoutResponse = exports.LogoutResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ChannelMsgRequest = exports.ChannelMsgRequest = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

var ChannelMsgResponse = exports.ChannelMsgResponse = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null
}

defineServer()
defineBalanceResult()
defineSession()
defineGameChannel()
defineMultiLoginOut()
defineLoginRequest()
defineLoginResponse()
defineRpcMsg()
defineLogoutRequest()
defineLogoutResponse()
defineChannelMsgRequest()
defineChannelMsgResponse()

function defineServer () {
  Server.encodingLength = encodingLength
  Server.encode = encode
  Server.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.server_id)) {
      var len = encodings.string.encodingLength(obj.server_id)
      length += 1 + len
    }
    if (defined(obj.server_type)) {
      var len = encodings.string.encodingLength(obj.server_type)
      length += 1 + len
    }
    if (defined(obj.server_name)) {
      var len = encodings.string.encodingLength(obj.server_name)
      length += 1 + len
    }
    if (defined(obj.server_ip)) {
      var len = encodings.string.encodingLength(obj.server_ip)
      length += 1 + len
    }
    if (defined(obj.client_port)) {
      var len = encodings.int32.encodingLength(obj.client_port)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.server_id)) {
      buf[offset++] = 10
      encodings.string.encode(obj.server_id, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.server_type)) {
      buf[offset++] = 18
      encodings.string.encode(obj.server_type, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.server_name)) {
      buf[offset++] = 26
      encodings.string.encode(obj.server_name, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.server_ip)) {
      buf[offset++] = 34
      encodings.string.encode(obj.server_ip, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.client_port)) {
      buf[offset++] = 40
      encodings.int32.encode(obj.client_port, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      server_id: "",
      server_type: "",
      server_name: "",
      server_ip: "",
      client_port: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.server_id = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 2:
        obj.server_type = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.server_name = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 4:
        obj.server_ip = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 5:
        obj.client_port = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineBalanceResult () {
  BalanceResult.encodingLength = encodingLength
  BalanceResult.encode = encode
  BalanceResult.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.code)) {
      var len = encodings.enum.encodingLength(obj.code)
      length += 1 + len
    }
    if (defined(obj.connector)) {
      var len = Server.encodingLength(obj.connector)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.backend)) {
      var len = Server.encodingLength(obj.backend)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.backend_pre)) {
      var len = Server.encodingLength(obj.backend_pre)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.code)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.code, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.connector)) {
      buf[offset++] = 18
      varint.encode(Server.encodingLength(obj.connector), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.connector, buf, offset)
      offset += Server.encode.bytes
    }
    if (defined(obj.backend)) {
      buf[offset++] = 26
      varint.encode(Server.encodingLength(obj.backend), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend, buf, offset)
      offset += Server.encode.bytes
    }
    if (defined(obj.backend_pre)) {
      buf[offset++] = 34
      varint.encode(Server.encodingLength(obj.backend_pre), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend_pre, buf, offset)
      offset += Server.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      code: 0,
      connector: null,
      backend: null,
      backend_pre: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.code = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.connector = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend_pre = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineSession () {
  Session.encodingLength = encodingLength
  Session.encode = encode
  Session.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    if (defined(obj.connector)) {
      var len = Server.encodingLength(obj.connector)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.backend)) {
      var len = Server.encodingLength(obj.backend)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.uid)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.connector)) {
      buf[offset++] = 18
      varint.encode(Server.encodingLength(obj.connector), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.connector, buf, offset)
      offset += Server.encode.bytes
    }
    if (defined(obj.backend)) {
      buf[offset++] = 26
      varint.encode(Server.encodingLength(obj.backend), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend, buf, offset)
      offset += Server.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      uid: 0,
      connector: null,
      backend: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.connector = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineGameChannel () {
  GameChannel.encodingLength = encodingLength
  GameChannel.encode = encode
  GameChannel.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    if (defined(obj.connector)) {
      var len = Server.encodingLength(obj.connector)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.backend)) {
      var len = Server.encodingLength(obj.backend)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.create_time)) {
      var len = encodings.int64.encodingLength(obj.create_time)
      length += 1 + len
    }
    if (defined(obj.reconnect_num)) {
      var len = encodings.int32.encodingLength(obj.reconnect_num)
      length += 1 + len
    }
    if (defined(obj.reconnect_time)) {
      var len = encodings.int64.encodingLength(obj.reconnect_time)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.uid)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.connector)) {
      buf[offset++] = 18
      varint.encode(Server.encodingLength(obj.connector), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.connector, buf, offset)
      offset += Server.encode.bytes
    }
    if (defined(obj.backend)) {
      buf[offset++] = 26
      varint.encode(Server.encodingLength(obj.backend), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend, buf, offset)
      offset += Server.encode.bytes
    }
    if (defined(obj.create_time)) {
      buf[offset++] = 32
      encodings.int64.encode(obj.create_time, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    if (defined(obj.reconnect_num)) {
      buf[offset++] = 40
      encodings.int32.encode(obj.reconnect_num, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.reconnect_time)) {
      buf[offset++] = 48
      encodings.int64.encode(obj.reconnect_time, buf, offset)
      offset += encodings.int64.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      uid: 0,
      connector: null,
      backend: null,
      create_time: 0,
      reconnect_num: 0,
      reconnect_time: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.connector = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        case 4:
        obj.create_time = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        case 5:
        obj.reconnect_num = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 6:
        obj.reconnect_time = encodings.int64.decode(buf, offset)
        offset += encodings.int64.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineMultiLoginOut () {
  MultiLoginOut.encodingLength = encodingLength
  MultiLoginOut.encode = encode
  MultiLoginOut.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.uid)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      uid: 0
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLoginRequest () {
  LoginRequest.encodingLength = encodingLength
  LoginRequest.encode = encode
  LoginRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    if (defined(obj.nickname)) {
      var len = encodings.string.encodingLength(obj.nickname)
      length += 1 + len
    }
    if (defined(obj.token)) {
      var len = encodings.string.encodingLength(obj.token)
      length += 1 + len
    }
    if (defined(obj.backend)) {
      var len = Server.encodingLength(obj.backend)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.uid)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.nickname)) {
      buf[offset++] = 18
      encodings.string.encode(obj.nickname, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.token)) {
      buf[offset++] = 26
      encodings.string.encode(obj.token, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.backend)) {
      buf[offset++] = 34
      varint.encode(Server.encodingLength(obj.backend), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend, buf, offset)
      offset += Server.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      uid: 0,
      nickname: "",
      token: "",
      backend: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 2:
        obj.nickname = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.token = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLoginResponse () {
  LoginResponse.encodingLength = encodingLength
  LoginResponse.encode = encode
  LoginResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.code)) {
      var len = encodings.enum.encodingLength(obj.code)
      length += 1 + len
    }
    if (defined(obj.msg)) {
      var len = encodings.string.encodingLength(obj.msg)
      length += 1 + len
    }
    if (defined(obj.backend)) {
      var len = Server.encodingLength(obj.backend)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.code)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.code, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.msg)) {
      buf[offset++] = 18
      encodings.string.encode(obj.msg, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.backend)) {
      buf[offset++] = 26
      varint.encode(Server.encodingLength(obj.backend), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend, buf, offset)
      offset += Server.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      code: 0,
      msg: "",
      backend: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.code = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        obj.msg = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineRpcMsg () {
  RpcMsg.encodingLength = encodingLength
  RpcMsg.encode = encode
  RpcMsg.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.msg_id)) {
      var len = encodings.enum.encodingLength(obj.msg_id)
      length += 1 + len
    }
    if (defined(obj.msg_server)) {
      var len = Server.encodingLength(obj.msg_server)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    if (defined(obj.msg_data)) {
      var len = encodings.bytes.encodingLength(obj.msg_data)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.msg_id)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.msg_id, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.msg_server)) {
      buf[offset++] = 18
      varint.encode(Server.encodingLength(obj.msg_server), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.msg_server, buf, offset)
      offset += Server.encode.bytes
    }
    if (defined(obj.msg_data)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.msg_data, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      msg_id: 0,
      msg_server: null,
      msg_data: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.msg_id = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.msg_server = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        case 3:
        obj.msg_data = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLogoutRequest () {
  LogoutRequest.encodingLength = encodingLength
  LogoutRequest.encode = encode
  LogoutRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    if (defined(obj.backend)) {
      var len = Server.encodingLength(obj.backend)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.uid)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.backend)) {
      buf[offset++] = 18
      varint.encode(Server.encodingLength(obj.backend), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.backend, buf, offset)
      offset += Server.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      uid: 0,
      backend: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.backend = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineLogoutResponse () {
  LogoutResponse.encodingLength = encodingLength
  LogoutResponse.encode = encode
  LogoutResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.code)) {
      var len = encodings.enum.encodingLength(obj.code)
      length += 1 + len
    }
    if (defined(obj.msg)) {
      var len = encodings.string.encodingLength(obj.msg)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.code)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.code, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.msg)) {
      buf[offset++] = 18
      encodings.string.encode(obj.msg, buf, offset)
      offset += encodings.string.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      code: 0,
      msg: ""
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.code = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        obj.msg = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineChannelMsgRequest () {
  ChannelMsgRequest.encodingLength = encodingLength
  ChannelMsgRequest.encode = encode
  ChannelMsgRequest.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.uid)) {
      var len = encodings.int32.encodingLength(obj.uid)
      length += 1 + len
    }
    if (defined(obj.rpc_msg)) {
      var len = RpcMsg.encodingLength(obj.rpc_msg)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.uid)) {
      buf[offset++] = 8
      encodings.int32.encode(obj.uid, buf, offset)
      offset += encodings.int32.encode.bytes
    }
    if (defined(obj.rpc_msg)) {
      buf[offset++] = 18
      varint.encode(RpcMsg.encodingLength(obj.rpc_msg), buf, offset)
      offset += varint.encode.bytes
      RpcMsg.encode(obj.rpc_msg, buf, offset)
      offset += RpcMsg.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      uid: 0,
      rpc_msg: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.uid = encodings.int32.decode(buf, offset)
        offset += encodings.int32.decode.bytes
        break
        case 2:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.rpc_msg = RpcMsg.decode(buf, offset, offset + len)
        offset += RpcMsg.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defineChannelMsgResponse () {
  ChannelMsgResponse.encodingLength = encodingLength
  ChannelMsgResponse.encode = encode
  ChannelMsgResponse.decode = decode

  function encodingLength (obj) {
    var length = 0
    if (defined(obj.code)) {
      var len = encodings.enum.encodingLength(obj.code)
      length += 1 + len
    }
    if (defined(obj.msg)) {
      var len = encodings.string.encodingLength(obj.msg)
      length += 1 + len
    }
    if (defined(obj.msg_data)) {
      var len = encodings.bytes.encodingLength(obj.msg_data)
      length += 1 + len
    }
    if (defined(obj.connector)) {
      var len = Server.encodingLength(obj.connector)
      length += varint.encodingLength(len)
      length += 1 + len
    }
    return length
  }

  function encode (obj, buf, offset) {
    if (!offset) offset = 0
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj))
    var oldOffset = offset
    if (defined(obj.code)) {
      buf[offset++] = 8
      encodings.enum.encode(obj.code, buf, offset)
      offset += encodings.enum.encode.bytes
    }
    if (defined(obj.msg)) {
      buf[offset++] = 18
      encodings.string.encode(obj.msg, buf, offset)
      offset += encodings.string.encode.bytes
    }
    if (defined(obj.msg_data)) {
      buf[offset++] = 26
      encodings.bytes.encode(obj.msg_data, buf, offset)
      offset += encodings.bytes.encode.bytes
    }
    if (defined(obj.connector)) {
      buf[offset++] = 34
      varint.encode(Server.encodingLength(obj.connector), buf, offset)
      offset += varint.encode.bytes
      Server.encode(obj.connector, buf, offset)
      offset += Server.encode.bytes
    }
    encode.bytes = offset - oldOffset
    return buf
  }

  function decode (buf, offset, end) {
    if (!offset) offset = 0
    if (!end) end = buf.length
    if (!(end <= buf.length && offset <= buf.length)) throw new Error("Decoded message is not valid")
    var oldOffset = offset
    var obj = {
      code: 0,
      msg: "",
      msg_data: null,
      connector: null
    }
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset
        return obj
      }
      var prefix = varint.decode(buf, offset)
      offset += varint.decode.bytes
      var tag = prefix >> 3
      switch (tag) {
        case 1:
        obj.code = encodings.enum.decode(buf, offset)
        offset += encodings.enum.decode.bytes
        break
        case 2:
        obj.msg = encodings.string.decode(buf, offset)
        offset += encodings.string.decode.bytes
        break
        case 3:
        obj.msg_data = encodings.bytes.decode(buf, offset)
        offset += encodings.bytes.decode.bytes
        break
        case 4:
        var len = varint.decode(buf, offset)
        offset += varint.decode.bytes
        obj.connector = Server.decode(buf, offset, offset + len)
        offset += Server.decode.bytes
        break
        default:
        offset = skip(prefix & 7, buf, offset)
      }
    }
  }
}

function defined (val) {
  return val !== null && val !== undefined && (typeof val !== 'number' || !isNaN(val))
}
